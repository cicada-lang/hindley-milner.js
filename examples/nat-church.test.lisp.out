(claim zero (nu (0 1) (-> 0 1 0)))
(claim add1 (nu (0 1 2) (-> (-> 0 (-> 1 2) 1) 0 (-> 1 2) 2)))
(claim iter-Nat (nu (0 1 2) (-> (-> 0 1 2) 0 1 2)))
(claim one (nu (0 1) (-> 0 (-> 0 1) 1)))
(claim two (nu (0) (-> 0 (-> 0 0) 0)))
(claim three (nu (0) (-> 0 (-> 0 0) 0)))
(claim four (nu (0) (-> 0 (-> 0 0) 0)))
(claim five (nu (0) (-> 0 (-> 0 0) 0)))
(claim six (nu (0) (-> 0 (-> 0 0) 0)))
(claim seven (nu (0) (-> 0 (-> 0 0) 0)))
(claim eight (nu (0) (-> 0 (-> 0 0) 0)))
(claim nine (nu (0) (-> 0 (-> 0 0) 0)))
(claim ten (nu (0) (-> 0 (-> 0 0) 0)))
(claim add (nu (0 1 2 3 4) (-> (-> 0 (-> (-> 1 (-> 2 3) 2) 1 (-> 2 3) 3) 4) 0 4)))
(claim add-rosser (nu (0 1 2 3) (-> (-> 0 1 2) (-> 3 1 0) 3 1 2)))
(claim mul (nu (0 1 2 3 4 5 6 7) (-> (-> (-> 0 1 0) (-> 2 3) 4) (-> 2 (-> (-> 5 (-> 6 7) 6) 5 (-> 6 7) 7) 3) 4)))
(claim power-of (nu (0 1 2 3 4 5 6 7 8 9 10) (-> (-> (-> 0 (-> 0 1) 1) (-> (-> 2 (-> (-> 3 (-> 4 5) 4) 3 (-> 4 5) 5) 6) 7) 8) (-> (-> 9 10 9) (-> 2 6) 7) 8)))
(claim power (nu (0 1 2 3 4 5 6 7 8 9 10) (-> (-> (-> 0 1 0) (-> 2 3) 4) (-> (-> 5 (-> 5 6) 6) (-> (-> 2 (-> (-> 7 (-> 8 9) 8) 7 (-> 8 9) 9) 3) 4) 10) 10)))
(claim true (nu (0 1) (-> 0 1 0)))
(claim false (nu (0 1) (-> 0 1 1)))
(claim if (nu (0 1 2) (-> (-> 0 1 2) 0 1 2)))
(claim and (nu (0 1 2 3) (-> (-> 0 (-> 1 2 2) 3) 0 3)))
(claim or (nu (0 1 2 3) (-> (-> (-> 0 1 0) 2 3) 2 3)))
(claim not (nu (0 1 2 3 4) (-> (-> (-> 0 1 1) (-> 2 3 2) 4) 4)))
(claim zero? (nu (0 1 2 3 4 5) (-> (-> (-> 0 1 0) (-> 2 3 4 4) 5) 5)))
(claim cons (nu (0 1 2) (-> 0 1 (-> 0 1 2) 2)))
(claim car (nu (0 1 2) (-> (-> (-> 0 1 0) 2) 2)))
(claim cdr (nu (0 1 2) (-> (-> (-> 0 1 1) 2) 2)))
(claim null (nu (0 1 2) (-> 0 1 2 1)))
(claim null? (nu (0 1 2 3 4) (-> (-> (-> 0 1 2 3 3) 4) 4)))
(claim shift-add1 (nu (0 1 2 3 4 5) (-> (-> (-> 0 1 1) 2 (-> 3 4) 3) (-> (-> 2 (-> 3 4) 3) (-> 2 (-> 3 4) 4) 5) 5)))
(claim sub1 (nu (0 1 2 3 4 5 6 7 8 9 10 11 12 13) (-> (-> (-> (-> (-> 0 1 0) (-> 2 3 2) 4) 4) (-> (-> (-> 5 6 6) 7 (-> 8 9) 8) (-> (-> 7 (-> 8 9) 8) (-> 7 (-> 8 9) 9) 10) 10) (-> 11 12 11) 13) 13)))
(claim sub (nu (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) (-> 0 (-> 0 (-> (-> (-> (-> (-> 1 2 1) (-> 3 4 3) 5) 5) (-> (-> (-> 6 7 7) 8 (-> 9 10) 9) (-> (-> 8 (-> 9 10) 9) (-> 8 (-> 9 10) 10) 11) 11) (-> 12 13 12) 14) 14) 15) 15)))
(claim lteq (nu (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20) (-> 0 (-> 0 (-> (-> (-> (-> (-> 1 2 1) (-> 3 4 3) 5) 5) (-> (-> (-> 6 7 7) 8 (-> 9 10) 9) (-> (-> 8 (-> 9 10) 9) (-> 8 (-> 9 10) 10) 11) 11) (-> 12 13 12) 14) 14) (-> 15 16 15) (-> 17 18 19 19) 20) 20)))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step base)))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step base)))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step base))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step base))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step base)))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step base)))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step base))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step base))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step (step (step (step base))))))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step (step (step (step base))))))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step (step (step base)))))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step (step (step base)))))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step base))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step base))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step (step (step (step (step (step (step (step (step (step base))))))))))))))))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step (step (step (step (step (step (step (step (step (step (step (step (step (step base))))))))))))))))))
(the (nu (0 1) (-> 0 1 0)) (lambda (t f) t))
(the (nu (0 1) (-> 0 1 0)) (lambda (t f) t))
(the (nu (0 1) (-> 0 1 1)) (lambda (t f) f))
(the (nu (0 1) (-> 0 1 1)) (lambda (t f) f))
(the (nu (0) (-> 0 0 0)) (lambda (t f) f))
(the (nu (0 1) (-> 0 1 1)) (lambda (t f) f))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step base)))
(the (nu (0 1) (-> 0 (-> 0 1) 1)) (lambda (base step) (step base)))
(the (nu (0 1) (-> 0 (-> 0 1) 0)) (lambda (base step) base))
(the (nu (0 1) (-> 0 1 0)) (lambda (base step) base))
(the (nu (0 1) (-> 0 1 0)) (lambda (base step) base))
(the (nu (0 1) (-> 0 1 0)) (lambda (base step) base))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step base)))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step (step base)))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step base))))
(the (nu (0) (-> 0 (-> 0 0) 0)) (lambda (base step) (step (step base))))
